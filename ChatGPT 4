FitCoach – Self-Coaching Fitness Platform
Introduction
FitCoach is an all-in-one self-coaching fitness platform transformed from the CoachTrackPro Enhanced App. It empowers individual users to plan, track, and analyze their fitness journey without needing a personal trainer or internet connection. Unlike the original CoachTrackPro (which was built around coach-client interactions), FitCoach is single-user only – there are no coach or client roles and no login/authentication screens. All data is stored locally on the user’s device, enabling full functionality offline. The app is built with modern React (using Vite) and designed as a Progressive Web App (PWA) so that users can install it on any device and use it anywhere, even with no internet access​
adueck.github.io
. Data is persisted via browser storage (LocalStorage and IndexedDB), and users can export or import their entire dataset as a .fitcoach JSON file for backup or transfer. This document serves as the project’s README and technical documentation, detailing the features, design, implementation, and deployment of FitCoach. All code and documentation are attributed to the project owner, Meshal Alawein, and include comprehensive comments for clarity and maintainability.
Core Goals
FitCoach was developed with several core goals in mind, all of which guided the transformation from the original project:
No Coach/Client Roles: Eliminate all multi-user or coach-client structures. The app is tailored for a single individual’s use with no separate admin/coach interface.
No Authentication: Remove login and user accounts entirely. The user’s data is readily available on their device without needing to sign in.
Local Data Persistence: Store all user data in the browser (using LocalStorage for lightweight data and IndexedDB for structured, large datasets). This ensures data is available offline and remains private to the user’s device​
blog.logrocket.com
​
blog.logrocket.com
.
Offline-First Functionality: Design the app as an offline-first PWA. All features (viewing dashboards, logging workouts, etc.) work without internet access. A service worker caches the entire app so it loads instantly and runs offline​
adueck.github.io
.
Data Export/Import: Implement seamless data backup and transfer via a custom .fitcoach file (JSON format). Users can export all their data to this file and later import it to restore their information on any device.
With these goals met, FitCoach becomes a standalone fitness companion that users fully control. Next, we detail the rich feature set that makes up the FitCoach platform.
Features
Dashboard
The Dashboard is an intuitive summary screen providing an overview of the user’s fitness progress and current plan. It uses a widget-based layout where each widget highlights a key aspect of the user’s health or training:
Training Progress: A widget shows recent workouts and progress this week (e.g. number of workouts completed vs. planned). It might display a small calendar or list of days with completed sessions.
Health Metrics Summary: Key health stats (like current weight, average sleep, HRV) are shown with arrows or colors indicating trends (e.g. weight ↑ or ↓ since last log).
Visual Trends: The dashboard includes elegant charts (built with the Recharts library) to illustrate data over time – for example, a line chart of body weight over the past 6 weeks, or a bar chart of weekly training volume. Recharts was chosen because it blends D3’s power with React’s ease of use, enabling responsive and stylish charts with an intuitive API​
dev.to
. These charts update automatically as new data is logged.
Nutrition Summary: A panel displays today’s calorie intake vs. goal and macronutrient breakdown (carbs/protein/fat) in a pie chart or bar graph. This gives immediate feedback if the user is on target with their diet.
Upcoming Plans: A short list of what’s coming up – for example, the next scheduled workout or a reminder to log a health metric – helps the user stay on track.
All dashboard widgets are updated in real-time from local data. The layout is responsive, rearranging into a single column on mobile devices for easy scrolling. Users can tap any widget to dive deeper (e.g., tapping the training widget navigates to the full Training Program section). The design emphasizes clarity: important numbers are bold, trends use clear up/down icons, and charts have tooltips for exact values. This data-centric approach ensures users get actionable insights at a glance.
Training Program Builder
The Training Program Builder is a comprehensive workout planner and log, allowing users to create and follow customized exercise programs:
Workout Planning: Users can create workout routines for different days of the week or cycles. For example, a user might define a “Push/Pull/Legs” split or a 5-day strength program. Each workout routine can be built by selecting exercises from the exercise library and specifying the target sets, reps, and/or duration for each exercise. The UI provides a drag-and-drop or ordered list interface to arrange exercises in the desired order for the workout day.
Exercise Library: FitCoach comes with a built-in library of common exercises (e.g. squat, bench press, deadlift, etc.), each with a description and muscle groups. Users can also add custom exercises. The library is stored locally (and included in the .fitcoach export) so it’s available offline. When building a workout, users pick from this list. An exercise search bar with autocomplete makes it easy to find exercises.
Logging Sets & Reps: During a workout, or after completing it, the user logs what they actually did for each exercise – e.g. weight lifted and reps for each set. The Training Log interface presents each exercise with input fields for sets, reps, weight, and any notes (like “felt easy” or “increase next time”). This logging can be done in an “Active Workout” mode (if using the app live during exercise) or later as a journal entry.
Progress Tracking: The program builder isn’t just for planning – it also visualizes progress. Each exercise can show a small sparkline or trend indicator of performance over time (e.g. a line showing the 1RM or top weight lifted each week). Users can click an exercise to see a detailed chart of their history with that movement, helping identify plateaus or improvements. For example, a bench press chart might show weight vs. date, highlighting personal records.
Offline and Persistent: All workout templates and logs are saved to IndexedDB. This means even if the user closes the app or is offline, their training data persists and loads on next use. The structure might involve an IndexedDB object store for workouts (plans) and another for logs (performance entries). This structured storage allows complex queries, like filtering logs by exercise or date range, even without a server​
blog.logrocket.com
.
User Interface: The training builder UI uses a clean, form-based design with collapsible sections. Uncluttered typography and spacing make it easy to input data even on a small screen. For each workout program, the interface might use an accordion or tabs for each day, and within each, list exercises with their target sets/reps. Logging mode might present a checklist of exercises with fields to fill in actual results.
Through the Training Program Builder, FitCoach essentially acts as the user’s personal logbook and planner, replacing the need for spreadsheets or paper journals. The experience is polished with immediate feedback – for instance, after logging a workout, the app can display a brief summary (“Total volume: 10,000 lbs, New PR in Squat!”) to keep the user motivated.
Nutrition Tracker
The Nutrition Tracker helps users plan and monitor their daily eating habits, focusing on calories and macronutrients, all within an offline-capable module:
Daily Meal Planner: Users can plan each day’s meals (breakfast, lunch, dinner, snacks) and record what they eat. The UI is organized by meal times; for each meal, the user can add multiple food items. Each food entry includes a name, portion size, calories, and macronutrient breakdown (proteins, carbs, fats). For convenience, the app might come pre-loaded with a small offline food database (for common foods) or allow the user to input custom nutritional info from labels.
Macro Calculator: At the top of the Nutrition screen, the day’s totals for calories and macros are displayed compared to the user’s targets. For example, it might show “1800 / 2000 kcal” along with macro bars for P/C/F (protein, carbs, fat). These targets can be set by the user in a settings section (and could be guided by simple recommendations, like calculating basal metabolic rate and adding a goal surplus/deficit). The calculator updates in real-time as foods are logged.
Food Logging: Adding a food item is straightforward – the user clicks “Add Food”, searches or selects from their saved foods, adjusts the quantity, and the app auto-calculates nutrients. Because FitCoach is offline-first, it does not rely on an external API for food data; instead, it either uses user-provided data or a tiny built-in dataset. All food entries are stored in IndexedDB (e.g. an object store for nutritionLogs with entries for each day and meal).
Meal Templates: To save time, users can define and reuse meal templates. For example, if a user often eats “Oatmeal with protein shake” for breakfast, they can save that as a template and add it in one click to any day. Under the hood, a template might be a JSON snippet of multiple foods with predefined quantities. The UI provides a “Save as Template” option after the user inputs a meal, and a list of saved templates to reuse. This encourages consistency and speeds up logging.
Historical View: The Nutrition Tracker includes a history view where users can scroll back through days or view a calendar heatmap of calorie intake. They can identify patterns (e.g. lower intake on weekends) and consistency. Charts might be used here too, for example a 7-day rolling calorie average line chart, or a bar chart of daily protein intake. These visualizations help in understanding diet adherence over time. Tooltips on these charts explain concepts like calorie surplus/deficit or macronutrient importance in simple terms, aligning with the educational aspect of the app.
User Interface: The nutrition UI uses color-coding for macros (e.g. protein in blue, carbs in orange, fat in green) and perhaps icons for meals. It’s designed to be quick to navigate so that users can log foods on the go. On mobile, adding a food might open a full-screen form for clarity. There’s also consideration for units (imperial vs metric) in portion sizes, configurable in settings.
Overall, the Nutrition Tracker encourages mindful eating by making it easy to record and review one’s diet. All data stays local; even if the user goes offline, they can continue adding meals and see their daily totals update.
Supplement & PED Management
FitCoach includes a dedicated section for tracking supplements and PEDs (Performance Enhancing Drugs), recognizing that advanced athletes may use these and want to log their usage and effects. This feature is handled with a careful, informative approach:
Supplement Log: Users can maintain a list of supplements or substances they are taking or have taken in the past. For each item, they can record details like name, dosage, timing/frequency, and purpose/rationale. For example, a user might log “Creatine Monohydrate – 5g daily – taken in the morning – purpose: improve strength and recovery.” Another example could be a PED like “Testosterone Cypionate – 200mg weekly – purpose: TRT”. The log is essentially a form that the user can fill for each supplement.
Schedule & Reminders: The app can display the schedule of when each supplement is taken. A calendar or timeline view shows active supplements and dosages on each day. While offline, the app can’t send push notifications, but it can still show a on-screen reminder if the user opens the app (“Don’t forget to take 5g Creatine today”). If the PWA is installed, we leverage the browser’s notification API for local reminders when possible (e.g., scheduling a notification via service worker at a given time) – though this may require user permission and is a progressive enhancement.
Historical Changes: For each supplement, FitCoach keeps a history of changes. If the user updates the dosage or stops/starts a supplement, the date of change is recorded. This way, they can look back and see, for instance, “Jan 2025: started 5g Creatine daily”, “Mar 2025: increased to 10g”, “Jun 2025: stopped”. This history is useful to correlate with performance changes or side effects. The UI might allow the user to mark a supplement as “active” or “inactive” and filter the view accordingly.
Side Effects & Notes: The app provides a notes section where users can log any side effects or general observations (e.g., “Noticed improved sleep” or “Experienced joint pain”). Each note can be tagged with a date and optionally linked to a supplement. For instance, a user could add a note under “Testosterone” saying “Month 2: acne as side effect”. These notes give qualitative context to the quantitative logs. In the data model, we might have an object store supplements (with current data for each) and another supplementHistory or simply embed history and notes within each supplement object.
Educational Tooltips: Given the potentially sensitive nature of PEDs, the app includes tooltips or info modals for common substances. If the user logs a known supplement (say, Vitamin D or Creatine), an info icon could be shown – clicking it might display a short description of its typical use and scientifically understood effects. This content would be pre-written (since offline) and meant to inform the user in layman’s terms. For example, “Creatine: A well-researched supplement that may improve muscle power output and hydration. Standard dose ~5g/day.” This aligns with the app’s educational aim without being judgmental.
Privacy: All supplement data is kept local and private. Some users might be concerned about logging PED usage; FitCoach, being offline-first, never uploads this data. The .fitcoach export is the only way data leaves the app, and that is initiated explicitly by the user.
By managing supplements and PEDs in the app, users get a holistic view of how these substances might be affecting their training and health. They can cross-reference supplement periods with performance graphs or health metrics (e.g., see bloodwork changes after starting a cycle). FitCoach thus serves as a personal health journal in addition to a training log.
Health Metrics
The Health Metrics section allows users to log and monitor various health and recovery indicators, bringing a more scientific insight into their fitness regimen. Users can track anything from blood test results to daily wellbeing scores:
Metric Logging: The app supports a range of metrics, including but not limited to: Bloodwork (e.g. testosterone levels, cholesterol, hemoglobin, etc.), Heart Rate Variability (HRV), Resting Heart Rate, Blood Pressure, Sleep Duration/Quality, Body Weight, Body Fat Percentage, and Recovery Scores (if the user uses a subjective scale or devices). Each metric has an input form. Some metrics like bloodwork are entered manually when available (with a date and the value, e.g., “Vitamin D: 30 ng/mL on 2025-04-01”), whereas others like daily sleep can be logged more regularly.
Visualization Over Time: For each metric, FitCoach generates graphs to show changes over time. For example, HRV could be shown as a line graph over weeks, weight as a trend line or area chart, and discrete lab readings as point plots on a timeline. Charts include tooltips that show the exact values and dates when hovering or tapping a point. These visualizations help users spot trends (e.g., a gradual increase in resting heart rate might indicate accumulating fatigue). The charts are interactive and built with the same Recharts library for consistency in style.
Scientific Guidance: A unique feature is that each metric comes with context. The UI provides short explanations or healthy ranges for metrics. For instance, if a user views their blood pressure log, the app might show “Normal BP is ~120/80 mmHg. Consistently high values (>130/90) may indicate hypertension.” Similarly, hovering over “HRV” might show a tooltip like “Heart Rate Variability: higher is generally better, indicating good recovery, but daily values can fluctuate”. These explanations are written in plain language to educate the user on what each metric means and why it matters. This transforms raw data into actionable knowledge, embodying the app’s scientific flair.
Trend Alerts: The Health Metrics module can generate simple alerts for notable changes. For example, if the user’s body weight drops or increases rapidly beyond a chosen threshold, or if a blood metric is outside the normal range, the app could highlight that value in red and perhaps list a recommendation (e.g., “Recent weight change is significant – ensure this is intentional and maintain adequate nutrition.”). These are rule-based flags (no internet needed) that guide the user’s attention.
Data storage: All metric entries are stored in IndexedDB under an object store (perhaps called healthMetrics), with a schema supporting different metric types and units. This allows the app to query, say, all metrics of type “bloodwork” easily, or retrieve the latest entry of each type for the dashboard.
UI and UX: The health logging interface might be a tabbed layout or simply a list of metric categories. For frequent metrics like weight or sleep, quick-add buttons could streamline entry (for example, a “+” button next to Weight on the dashboard jumps to a weight entry form pre-filled with today’s date). For metrics that are less frequent (bloodwork), the app might encourage the user to log whenever they get new lab results. Consistency and accuracy are encouraged through the design; for example, if a user hasn’t logged sleep in a while, that field might be subtly highlighted or prompted in the smart recommendations.
By centralizing health data, FitCoach helps users connect the dots between training, nutrition, supplementation, and outcomes. This holistic view can reveal insights (like “I lifted more in the gym when my sleep was 8+ hours” or “My cholesterol improved after I changed my diet”), empowering users to adjust their lifestyle for better results.
Smart Recommendations
One of the powerful aspects of FitCoach is its Smart Recommendations engine. This is essentially the user’s digital coach, providing rule-based feedback and guidance derived from the data the user logs. While it’s not an AI or ML system (yet), the logic is structured to be easily upgradable to a machine-learning model in the future. Current smart recommendations include:
Plateau Alerts: The app detects when the user might be hitting a plateau in training. For example, if the user’s logged performance on a particular exercise has not improved for the last few sessions, a recommendation might trigger: “It looks like your bench press has plateaued for 3 workouts. Consider changing your rep scheme or adding a deload week.” This rule might check the last 3–5 logs of each major exercise for stagnation.
Recovery Warnings: If health metrics indicate poor recovery – say, consistently low sleep hours or a downward trend in HRV – the app will advise the user to prioritize rest. E.g., “Your average sleep this week is below 6 hours. Adequate sleep is crucial for recovery; try to get more rest for better results.”
Nutrition Feedback: The Nutrition Tracker ties in to give diet recommendations. If, for instance, the user’s protein intake has been below target on most days, a tip might appear: “Your protein intake is often below your goal. Increasing protein can aid muscle repair – consider adding a protein-rich snack.” Similarly, if calories are far above goal and weight is increasing faster than desired, it might warn about potential fat gain.
Logging Reminders: The app notices gaps in logging and can remind the user to keep information up to date. For example, if no workout has been logged for over a week, the dashboard could gently nudge: “No workouts logged this week. Stay on track by planning your next session.” Or if the user set a weekly goal (like 3 workouts a week) and it’s Sunday with only 2 logged, a reminder to do a workout (or log a missed one) can appear. These reminders are local notifications or in-app messages since the app is offline (they don’t rely on server push).
Goal Milestones: When the user achieves a significant milestone (e.g., hitting a target weight, or completing a 12-week program), the app congratulates them and suggests next steps. For example, upon reaching a goal weight, it might say “Congrats on reaching 70 kg! Consider setting a new goal or focusing on maintenance – check your nutrition plan.”
Structured for ML Upgrade: Under the hood, all these recommendations are generated by a modular system. We have a recommendationsEngine module that pulls data from various stores (training, nutrition, health) and runs a series of rules. Each rule is encapsulated (for example, a function checkPlateau(exerciseLogs) returns a message or null). The architecture could look like:
javascript
Copy
Edit
function generateRecommendations() {
  const recs = [];
  recs.push(...checkTrainingLogsForPlateaus());
  recs.push(...checkHealthMetrics());
  recs.push(...checkNutritionConsistency());
  // ... other checks
  return recs;
}
This clear separation means in the future, we could replace or augment these rules with an ML model that looks at the same data and provides predictions/advice. The UI simply takes the array of recommendation strings (each possibly with a “why” link for more info) and displays them on the dashboard or a dedicated “Coach’s Tips” section.
The Smart Recommendations act like a safety net and a motivator – ensuring the user doesn’t unknowingly drift off course. All advice is given with a supportive tone. Thanks to the offline design, these insights are computed on-device instantly. As more data accumulates, the recommendations become even more personalized (for example, noticing long-term patterns like seasonal changes in activity). In sum, this feature embodies the “coach” in FitCoach, guiding users using their own data.
Design and Branding
FitCoach’s design philosophy is an elegant, data-centric aesthetic with a scientific flair. The goal is to make the app feel like a personal fitness lab, without overwhelming the user. Key design and branding elements include:
Color Scheme: A clean, modern color scheme with high contrast for readability. We use a neutral dark text on light background for main content, supplemented by accent colors for data visualization and status indicators. For instance, a cool blue or green for positive progress, and a subtle red/orange for areas needing attention. These colors are used in charts and icons to intuitively convey meaning (green = good/improving, red = needs action, etc.). The scientific flair comes through in the form of subtle grid lines on charts, and perhaps a dash of lab-themed color (like a test tube green or blueprint blue) for highlights.
Typography: The app uses a simple, high-readability typography system. A sans-serif font (for example, Helvetica Neue, Roboto or Lato) is used for body text and numbers because of its clean, modern look. Headings are slightly heavier or a complementary sans-serif for clear hierarchy. All text is sized for comfortable reading on both desktop and mobile (with responsive scaling). Important numbers (like weights, calories) are large and bold to stand out. Scientific terms, when used, are accompanied by simpler descriptions (either in parentheses or via tooltips) to ensure understanding.
Logo & Branding: FitCoach features a simple and meaningful logo representing self-improvement and progress. The logo might be an abstract symbol – for example, an upward arrow combined with a human figure or graph line, indicating growth and tracking. It’s kept minimalistic to match the app’s clean design. The branding across the app (splash screen, install icon, etc.) uses this logo and the app name clearly, so users recognize it on their device. All branding assets are included in the project (e.g., PWA manifest icons in various sizes for installation).
Layout & Aesthetics: The UI layout is structured and data-centric. We avoid decorative fluff and focus on presenting information clearly. Sections are separated by clear headings or cards. For example, each major feature (Training, Nutrition, etc.) might use a card or panel with a brief description or icon. Spacing is used to chunk information into digestible pieces. Graphs and charts are given significant space so they’re easy to read. In terms of flair, we might incorporate some subtle animations – e.g., when a new data point is added to a chart, it could highlight or pulse briefly. Transition animations (like sliding between sections) make the experience smooth. However, we ensure these never hinder performance, especially on mobile.
Tooltip System: A hallmark of the design is the comprehensive tooltip system for education. Throughout the app, wherever a scientific or technical term appears, it is either explained in-line or has an info icon that can be tapped for more info. For example, terms like “HRV”, “TRT”, “hypertrophy”, or “deload” might not be known to all users. Hovering (on desktop) or tapping (on mobile) a small ? icon next to such terms will show a brief, friendly explanation. These tooltips are short (one or two sentences) and in plain language. They aim to educate without overwhelming: “HRV (Heart Rate Variability): A measure of fluctuations in time between heartbeats. Higher HRV generally indicates better recovery and stress resilience.” The tooltip component is implemented using a lightweight library or custom React component, and styled to fit the app’s theme (perhaps a subtle drop shadow and the app’s accent color for the text).
Educational Focus: In line with the tooltip approach, various parts of the UI have small notes or tips built in. For instance, at the bottom of the Bloodwork section, a note might read “Remember: Always consult a medical professional for any concerning lab results.” In the workout builder, a tip like “Compound movements (using multiple joints) are effective for building strength.” These are static pieces of educational content placed contextually, reinforcing the app’s value as a self-coaching tool. We balance this by not making the UI too text-heavy at first glance – tips might be hidden behind expandable “Did you know?” sections so that power users can ignore them if desired.
Overall, the design aims for a professional yet approachable feel – much like having a conversation with a knowledgeable coach or scientist who explains things clearly. The aesthetic choices (colors, fonts, logo) align with self-improvement and progress, making the user feel that they are using a serious tool for their personal development. Yet the simplicity and explanations ensure it’s not intimidating for someone who’s not an expert.
Technical Implementation
Architecture & Stack
FitCoach is built as a single-page application (SPA) using React (with functional components and Hooks) and bootstrapped by Vite for a fast, modern development experience. The project structure is modular to accommodate the various features:
Components: The UI is divided into reusable React components. For example, Dashboard.jsx contains the overall dashboard layout, with child components like ProgressWidget, NutritionWidget, ChartCard, etc. Each major feature likely has its own section component (e.g., TrainingPage.jsx, NutritionPage.jsx, etc.) and further subcomponents (WorkoutPlanEditor, MealList, MetricChart, etc.).
State Management: Given the app is offline-first and uses IndexedDB for persistence, state is managed using a combination of React local state and context. For transient UI state (like a form input being filled, or a currently loaded workout), component state or Context API is used. For persistent data, the source of truth is in IndexedDB. FitCoach uses a small data layer to interface with IndexedDB (for example, a set of functions like getWorkouts(), saveWorkout(workout), etc., possibly wrapped with a library like Dexie for convenience). When data is fetched or mutated, the React state is updated accordingly to re-render the UI. We avoid heavy state libraries like Redux since the app’s complexity is manageable and context + hooks (e.g., useReducer for some parts) suffice.
Routing: We use a client-side router (such as React Router) to allow navigation between sections (Dashboard, Training, Nutrition, etc.) without full page reloads. For PWA offline capability, the router is configured to use browser history in a way that’s compatible with static file serving (e.g., using HashRouter for GitHub Pages deployment, or proper fallback on other hosts).
PWA Service Worker: FitCoach is configured as a Progressive Web App. We leverage the vite-plugin-pwa plugin for Vite to generate a service worker and manifest. The service worker is set to cache all the static assets and fallback to cache for offline use. In fact, we configure Workbox via the plugin to cache every file (JS, CSS, images, and even the index.html) so that once the app is installed or loaded, it’s entirely available offline​
adueck.github.io
. The manifest (manifest.json) includes the app name, icons, theme color, and offline start URL, enabling “Add to Home Screen” functionality on mobile. With this setup, the app can be installed and run like a native app and is fully functional without network after the first load.
LocalStorage & IndexedDB: For data storage, we implement a dual strategy: simple settings or small bits of info go to LocalStorage, whereas bulk data goes to IndexedDB for structured storage​
blog.logrocket.com
. For example, a user’s preference (like units or theme mode) might be a LocalStorage entry, but their workouts, logs, and nutrition data are stored in IndexedDB (via an abstraction such as Dexie). This approach is because LocalStorage is easy but limited (synchronous and ~5MB limit, string-only), and IndexedDB is more robust for larger, complex data sets (it can handle binary files, large JSON, etc., and is asynchronous). The Dexie library can be used to simplify IndexedDB calls. In our code, we create a database (perhaps named FitCoachDB) with tables like workouts, logs, nutrition, supplements, metrics, etc. Each has an appropriate schema (e.g., workouts might have an auto-increment ID and a name, logs might use a compound index of date + workoutId). By using IndexedDB, the app ensures data will persist long-term in the browser and can be queried efficiently even offline​
blog.logrocket.com
.
Offline-First and PWA Details
Making FitCoach work offline-first required careful consideration:
Caching Strategy: The service worker uses a precache for all application shell files (the HTML, JS bundle, CSS, and static media). We configure glob patterns so that all assets produced by the Vite build are cached​
adueck.github.io
. Additionally, the assets in the /public folder (like the logo and manifest) are included in caching​
adueck.github.io
. When the user is online and a new version is deployed, the service worker will fetch updated files in the background and later trigger an “update available” prompt (this is handled by the PWA plugin’s default behavior). If the user is offline, the service worker serves all content from cache, allowing uninterrupted usage.
Dynamic Data Caching: Since all user data is local (no server API calls), we don’t have to cache network requests for data – the app simply reads from IndexedDB. However, if we ever integrate any external data (for example, a one-time fetch of a food database or an update check), we would use a network-first or cache-first strategy as appropriate with the service worker. Currently, FitCoach’s offline mode is straightforward: everything the app needs is stored in the browser after installation.
Working Offline: We tested the app thoroughly by loading it and then disconnecting from the internet. The full workflow (open app, view dashboard, log a workout, add a meal, etc.) works with zero network requests. This meets the core requirement of being able to use it on the go, such as in a gym with poor signal. As one PWA case study notes, SPAs with service workers can be made totally self-contained so they work even without internet after the first load​
adueck.github.io
. FitCoach achieves this by caching all application files and by not depending on any live data source.
Data Export & Import (.fitcoach File)
To ensure users have control over their data, FitCoach provides an Export and Import feature using a custom .fitcoach file (which is essentially a JSON file with a specific structure). This allows backups, manual data transfers, or just peace of mind for the user. Here’s how it works:
Export Process: When the user chooses to export data (accessible perhaps via a Settings screen or an “Export Data” button on the dashboard), the app gathers all relevant data from LocalStorage and IndexedDB. We assemble a single JavaScript object that contains all the user’s information. For example:
json
Copy
Edit
{
  "workouts": [...],
  "logs": [...],
  "nutrition": [...],
  "supplements": [...],
  "metrics": [...],
  "settings": { ... }
}
Each array contains objects representing the entries in that category. Once this object is ready, we convert it to a JSON string with JSON.stringify. We then trigger a download in the browser: create a Blob from the JSON string and use a hidden <a> tag with URL.createObjectURL(blob) to download it. The file is named with a .fitcoach extension, for example fitcoach-export-2025-04-15.fitcoach. This .fitcoach extension is essentially .json but unique to our app so that it’s recognizable. (It also allows in future to register the app to handle such files.) The export code includes proper error handling. If any part of data retrieval fails, the user is notified. We also JSON.stringify each LocalStorage key’s value (since LocalStorage values are stored as strings – in our app, we likely already store JSON in them). Essentially it’s similar to doing JSON.stringify(localStorage) and including IndexedDB data​
stackoverflow.com
, but structured more cleanly. We keep the JSON human-readable (with indentation) so that if a tech-savvy user opens the file in a text editor, they can see their data.
Import Process: Conversely, the Import feature lets a user load a .fitcoach file (previously exported) to populate the app’s data. The UI for this is an <input type="file"> that accepts .fitcoach files. When a file is selected, the app reads it using the File API (as text) and then JSON.parse the contents. We then verify the structure (basic validation to ensure it has the expected keys). After validation, the app clears existing data (with user confirmation) and then iterates through the imported data to save it into IndexedDB and LocalStorage. For IndexedDB, we use bulk put operations for efficiency. For LocalStorage, we loop through the settings object (and any other data that was stored in LocalStorage) and set the items. Essentially, we reverse the export process:
javascript
Copy
Edit
const importedData = JSON.parse(fileText);
importedData.workouts.forEach(w => db.workouts.put(w));
// ... similarly for logs, nutrition, etc.
for (const [key, value] of Object.entries(importedData.settings)) {
  localStorage.setItem(key, JSON.stringify(value));
}
This will rebuild the entire dataset to the state when export was done​
stackoverflow.com
. The user is then informed the import was successful and the app state updates (we may prompt a refresh or simply reinitialize state from the DB). We also handle the case where a user might import on a brand new device where no data existed – the app will create the IndexedDB schema first (our DB initialization code runs on app load) then proceed with inserts.
Use Cases: A typical use case is a user exporting their data as a backup to cloud or to transfer data from a laptop to a phone. Since there is no server sync, this manual step is the way to move data. We clearly document this in the README and the app’s UI: e.g., “Use export to back up your data or transfer it to another device. You can import a FitCoach file to restore data.”
Security & Privacy: The exported .fitcoach file is a plain JSON containing potentially sensitive personal data. We advise users to keep it safe and only import files from sources they trust (since importing is basically trusting the file’s content to be correct JSON – we do basic validation, but a malicious crafted file could theoretically try to exploit the app, though the attack surface is limited in an offline environment). If needed, we could implement optional encryption for the export (user-provided password to encrypt the JSON), but that might be overkill for now. At minimum, documentation reminds users that the file contains personal health information.
Through the Export/Import feature, FitCoach provides data ownership to the user – a key benefit over many cloud-based fitness apps. The implementation is designed to be robust and user-friendly, hiding the technical details behind simple buttons.
Code Documentation and Commenting
All source code in FitCoach is thoroughly commented and documented to help future maintenance and to attribute the original author. Key aspects of code documentation include:
Header Comments: Each major source file includes a header comment block stating the file’s purpose and author. For example, at the top of Dashboard.jsx we include:
jsx
Copy
Edit
/** 
 * Dashboard.jsx – Main dashboard UI component 
 * 
 * Displays summary widgets for training, nutrition, and health data. 
 * Part of FitCoach (CoachTrackPro transformed) by Meshal Alawein, 2025. 
 */
This pattern is followed for all significant modules. It ensures that Meshal Alawein’s ownership is clearly indicated in the codebase.
Function & Module Docs: We use JSDoc-style comments for complex functions and classes. For instance, the recommendation engine module might have:
js
Copy
Edit
/**
 * Analyze recent training logs to detect plateaus.
 * @param {Array} logs - Array of workout log entries for an exercise.
 * @returns {String|null} Recommendation message if plateau detected, otherwise null.
 */
function checkPlateau(logs) { ... }
This not only explains what the function does, but also its inputs and outputs. Such documentation helps if others (or Meshal in the future) want to extend the logic or integrate ML.
Inline Comments: Throughout the code, we insert comments to explain non-obvious logic. For example, in the service worker registration script we might add a comment why we’re doing a certain check. Or in the data import routine:
js
Copy
Edit
// Clear existing data before importing, to avoid duplicate entries
await db.delete(); // delete the old IndexedDB
db = await initDB(); // recreate a fresh DB
Each step is explained so that someone reading the code understands the rationale. We especially comment on anything related to offline syncing or PWA quirks (since those can be tricky).
README Documentation: In addition to code comments, this document (and the in-repo README.md) serves as comprehensive documentation of the system. It is structured for easy reading, covering features and technical details, so that a developer or user reading it gets a clear picture of how things work. All information here is attributed to Meshal Alawein as the author and owner.
Attribution: If any external code or library is used, we follow their license requirements for attribution. For example, if we include a snippet from Stack Overflow or use an open-source icon, we credit it in comments or documentation. This ensures the project respects intellectual property. However, the majority of FitCoach’s code is original.
The result is a codebase that is not only functional but also maintainable and transparent. Future contributors or auditors can quickly see the intent behind code sections, and Meshal’s authorship is clearly stamped across the project. This level of documentation is especially important for a one-developer project that might be revisited after some time – the comments serve as reminders of why decisions were made.
Deployment and Packaging
FitCoach is designed to be easily deployable and distributable in various forms (web app, desktop app, mobile app). Here we outline how to package and deploy the application, including configurations for popular hosting services and steps to wrap the app for desktop/mobile.
Web Deployment (Netlify, Vercel, GitHub Pages)
The simplest way to share FitCoach is as a web app. After building the app, you get a set of static files (since it’s an SPA). We provide configurations for:
Netlify: Netlify is ideal for SPAs. We include a netlify.toml configuration file in the project which ensures proper redirect for single-page routing (so that direct URL navigation works). The config contains:
toml
Copy
Edit
[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
ensuring that all routes fall back to index.html (since the React Router will handle actual in-app routes). To deploy on Netlify, one can simply drag & drop the dist/ folder on the Netlify dashboard or link the Git repository – our README’s deployment section gives step-by-step instructions. We also set up the build command (npm run build) and publish directory (dist) for convenience.
Vercel: Vercel is similarly straightforward. We include a vercel configuration (either through a vercel.json or via documentation). With Vercel, if the repo is connected, it auto-detects Vite React app settings. We ensure that the vite.config.js is configured with correct base if deploying to a path. The app should work on Vercel out of the box. If any special routing config is needed, we document it (for example, using Vercel’s rewrite rules, although for a SPA it usually isn’t needed as Vercel handles that).
GitHub Pages: Deploying to GitHub Pages requires either using a branch or the GitHub Pages action. We include instructions and a workflow file for GitHub Actions that can build and deploy the app to the gh-pages branch. Since GitHub Pages doesn’t handle client-side routes by default, we have two approaches documented: using HashRouter in React (so routes are #/train instead of /train), or a trick to serve a 404.html that redirects to index.html. We opted for HashRouter for simplicity in the GH Pages context. The README’s deployment section explains how to set BASENAME for the router and how to run npm run deploy (if using a library like gh-pages) to push to GitHub Pages.
For all these platforms, the app being a PWA means once deployed, users can install it. The web manifest and service worker are crucial here. We verify that on each platform the app serves with HTTPS (required for PWA) and correct MIME types. The manifest file and icons are placed in /public so they will be at the root of the deployed site. We’ve tested deployment on each service to ensure the offline functionality still works after hosting (some platforms might alter headers or etc., but our configuration accounts for that). In summary, FitCoach can be accessed via a normal URL and still provide an app-like offline experience.
Desktop Application (Electron)
FitCoach can be packaged as a desktop application using Electron, allowing it to run as a standalone app on Windows, macOS, or Linux. We provide a guide and necessary configuration for this conversion:
Electron Setup: We include an electron.js (or main.js) entry file for Electron in the project. This script creates a desktop window and loads the FitCoach app into it. For example:
js
Copy
Edit
const { app, BrowserWindow } = require('electron');
const path = require('path');
function createWindow() {
  const win = new BrowserWindow({
    width: 1200, height: 800,
    webPreferences: { nodeIntegration: false }
  });
  // Load the built index.html from Vite’s output
  win.loadFile(path.join(__dirname, 'dist/index.html'));
}
app.whenReady().then(createWindow);
This ensures the Electron app displays the same content. Because FitCoach is a fully offline SPA, it doesn’t need a local server – it just loads the files from disk. In development, we might load http://localhost:5173 (the Vite dev server) for convenience​
medium.com
​
medium.com
, but for production we use the built files.
Packaging: We integrate electron-builder to create executables. The repository includes configs (like electron-builder.json or appropriate package.json fields) specifying app name, icons, and desired artifact formats (e.g., AppImage for Linux, DMG for Mac, NSIS for Windows). The build process would typically be: first run npm run build (to build the web app), then run electron-builder to package that output with the Electron runtime. We provide an NPM script for this, like "desktop:build": "electron-builder".
Native Features: Even though FitCoach doesn’t require network, as a desktop app it could leverage filesystem access for the export/import (e.g., directly invoke a file dialog to save the .fitcoach file to any location, rather than the in-browser download which might be sandboxed). We note in the documentation that future versions could integrate such enhancements for the desktop version. For now, the electron app uses the same in-app export/import, but Electron’s environment could allow a better file picker integration (we leave hooks in code for detection of Electron vs web environment, for instance checking window.process && window.process.versions.electron).
Distribution: The README guides how to obtain the packaged app. If Meshal or others distribute FitCoach, they can attach the installer files from electron-builder. The app’s icon and name will show appropriately on the user’s system. Since all data remains within the app (IndexedDB in Electron is stored in the user’s AppData folder typically), the user’s privacy is still intact.
By following the provided Electron guide, FitCoach users who prefer a desktop program (or who want offline access without opening a browser) can have that experience seamlessly.
Mobile Application (Capacitor)
In addition to web and desktop, FitCoach is prepared for mobile packaging using Ionic Capacitor. Capacitor essentially wraps the PWA into a native container for iOS/Android. We chose Capacitor (over Cordova) for its modern support and simplicity in leveraging the existing web code​
capacitorjs.com
. Key points:
Setup: We include instructions to initialize Capacitor. After building the web app (npm run build), one would run npx cap init (to initialize Capacitor with an app name and ID), then npx cap add android or ios to create the native projects. The dist/ folder is then copied into the native project as the web asset directory (Capacitor does this via npx cap copy).
Offline Functionality: Since our PWA is already offline-ready, when Capacitor loads the app in a WebView, it benefits from the same service worker caching. This means the app on a phone will work offline just as in the browser. One nuance: iOS WKWebView doesn’t allow service workers by default for local files, but Capacitor can be configured to enable them, or we use Capacitor’s built-in offline support. In practice, because the app doesn’t need external calls, even without a service worker the static files are bundled in the app, so offline is a given. For a truly PWA experience on mobile outside the WebView, users can also install the web version. But the Capacitor native app allows access to things like native share dialogs, file system, or push notifications if we ever add them.
Deploy to App Stores: We provide guidance on opening the Xcode or Android Studio projects that Capacitor generates, setting the app icon (we supply the same logo in required sizes), and running on devices. Since no special native plugins are required for core functionality (FitCoach doesn’t need camera, GPS, etc., at least not yet), the process is straightforward. Developers can then use Xcode/Android Studio to compile and submit to the App Store or Play Store. We note any app store requirements (like a privacy policy, since the app stores might require one even if data never leaves the device – we provide a simple privacy statement that “no personal data is collected or transmitted by the app”).
Capacitor Plugins: Our documentation mentions that if the user wants, they can integrate additional Capacitor plugins, for example the Filesystem API to handle the export file differently on mobile (like saving the .fitcoach file to Downloads). Out of the box, the web-based download might not work in a WebView, so we include a fallback for Capacitor: using the Filesystem plugin to write the file. This is an advanced detail; for initial release, one might simply instruct the user to copy the JSON text or something. But we aimed for completeness: if running under Capacitor, detect it and use Filesystem.writeFile to create the export in a shareable location. Similarly, use a file picker for import via Capacitor’s Dialogs or Filesystem.
By following the Capacitor guide, FitCoach can be installed as a native app, leveraging the convenience of app stores and native app launch, while still being the same codebase. The result is a unified development effort for web, desktop, and mobile.
Packaging as a Downloadable ZIP
For users who may want to self-host or just use the app directly, we provide a downloadable ZIP package of the full project. This ZIP (for example, FitCoach_v1.0.zip) contains:
The compiled static web app (the dist/ folder with index.html, assets, etc.), so that a user can simply unzip and open index.html in a browser to run FitCoach (or host it on a local server).
The source code of the project (all React source files, etc.) for transparency and for any developer who wants to inspect or modify it.
A copy of this README and other documentation (like a LICENSE file, a CONTRIBUTING guide if applicable).
Configuration files for PWA, Netlify, etc., as described above.
We ensured that opening index.html from the file system will at least show the app; however, due to browser security, service worker might not work from file:// URL. Therefore, for truly offline use via simply opening the file, the app will still function (it will just not have the service worker caching, but since all files are local, it doesn’t matter). We note in the README that for best results, using a simple HTTP server (or the deployed version) is recommended. The ZIP packaging is mainly for distributing the app outside of app stores or websites – for example, sharing at a conference or among a group where they can just run it locally. It’s also a convenient bundle for backup.
Installation & Development Setup
For developers or advanced users who want to run FitCoach from source or modify it, the following instructions are provided:
Prerequisites: Ensure Node.js (>=14 or 16, as required by Vite) and npm (or yarn) are installed on your system.
Obtaining the Source: Clone the repository from GitHub (or unpack the provided source ZIP).
bash
Copy
Edit
git clone https://github.com/meshal/FitCoach.git  
cd FitCoach
Install Dependencies: Run npm install to fetch all required packages. This includes React, the chart library (Recharts), Dexie (for IndexedDB), Vite, and other utility libraries.
Run in Development: Start the development server with:
bash
Copy
Edit
npm run dev
This uses Vite’s dev server (usually at http://localhost:5173) and will automatically open the app in your browser. Thanks to hot module replacement, you can edit source files and see changes live.
Build for Production: When ready to test a production build (or to deploy), run:
bash
Copy
Edit
npm run build
This will output the optimized static files to the dist/ directory. You can test the production build by running a local static server, e.g. npm install -g serve then serve dist. This is important to test PWA functionality; open the app and then go offline to confirm everything works.
PWA Testing: After building, you can also test the PWA install prompt. In Chrome/Edge, you should see an installable icon in the address bar. Installing it should give you a standalone app window. This is the same experience your users will have.
The repository contains a README.md (essentially this document) for quick reference. We also include notes on troubleshooting common issues (like “If you don’t see the PWA install option, check that you served via HTTPS or localhost as service workers require secure context”).
Future Enhancements
While FitCoach already covers a vast array of functionality, we envision future enhancements to make it even more powerful:
Machine Learning Integration: As hinted, the smart recommendation system could be augmented with ML. For instance, using TensorFlow.js or a pretrained model to predict overtraining or to suggest optimal exercise rotation based on the user’s history. The groundwork is laid out, and future updates could add a module that runs locally (keeping the offline spirit) to analyze data patterns more deeply.
Cloud Sync (Optional): For users who do want cloud backup or multi-device sync without manual exporting, an optional encrypted sync feature could be added. Perhaps using something like Firebase or a simple Dropbox/WebDAV integration. This would always be opt-in, respecting the user’s choice to keep data offline.
Community & Sharing: We could allow users to export individual programs or meal plans as sharable files (separate from the full backup). That way, communities of users could share workout routines or recipes by exchanging small .fitcoach snippets. This would still be offline (just file exchange).
Enhanced Analytics: Additional charts and analytics, such as correlation analysis (e.g., correlate sleep hours with workout performance), could provide even more insight. Advanced users might enjoy seeing these “lab reports” of their fitness data.
UI Themes: Add a dark mode (with proper high-contrast for charts) since many users prefer dark theme during workouts or at night. Also possibly a high-contrast mode for accessibility.
Accessibility: Ensure the app meets accessibility standards (ARIA labels on charts and form fields, ability to navigate via keyboard, screenreader-friendly text for data visualizations). This would broaden the user base and is part of good design.
Plugin System: Modularize things so that, for example, if someone doesn’t care about the Supplement section, they could toggle it off. Or future “modules” could be plugged in. This is more of a long-term idea, to make FitCoach a platform that can be extended (maybe by Meshal or open-source contributors).
All these possibilities remain open. The current version, however, provides a solid, comprehensive foundation for self-guided fitness management.
Conclusion & Credits
FitCoach demonstrates how a coach-client fitness app can be successfully transformed into a personal fitness platform that puts the individual in control. By removing external dependencies and focusing on offline capability, we created a tool that is available anytime, anywhere – whether you’re in a gym basement with no signal or simply prefer not to rely on cloud services. The combination of training, nutrition, supplementation, and health tracking in one place ensures that users have a holistic view of their progress. The educational design means it’s not just a tracker, but also a learning companion, helping users understand the “why” behind their routines and data. This project (code and documentation) is authored by Meshal Alawein. All rights are reserved to the owner. The code is thoroughly documented with Meshal’s attribution in all files. If you use or modify this project, please retain the attribution to respect the original work. The comprehensive README (this document) should give anyone – developer or end user – a clear guide to using and understanding FitCoach. We hope that this platform will empower fitness enthusiasts to coach themselves with confidence and scientific insight. Meshal Alawein – 2025
